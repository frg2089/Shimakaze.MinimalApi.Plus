using System.Collections.Immutable;

using Humanizer;

using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

using Shimakaze.MinimalApi.Plus.SourceGenerator.Internal;
using Shimakaze.MinimalApi.Plus.SourceGenerator.Metadata;

using static Microsoft.CodeAnalysis.CSharp.SyntaxFactory;

namespace Shimakaze.MinimalApi.Plus.SourceGenerator;

[Generator(LanguageNames.CSharp)]
public sealed class EndpointsGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        context.RegisterImplementationSourceOutput(
            context.SyntaxProvider.ForAttributeWithMetadataName(
                KnownTypes.ApiEndpointsAttribute[8..],
                (node, _) => node is not null,
                (context, _) => context.TargetSymbol as INamedTypeSymbol)
            .Collect(),
            Generate);
    }
    private static void Generate(SourceProductionContext context, ImmutableArray<INamedTypeSymbol?> data)
    {
        IEnumerable<INamedTypeSymbol> types = data
            .OfType<INamedTypeSymbol>()
            .Where(i =>
            {
                switch (i)
                {
                    case { TypeKind: TypeKind.Class, IsAbstract: false, IsGenericType: false }:
                        return true;
                    case { IsGenericType: true }:
                        context.Report(DiagnosticDescriptors.API0002, i, i!);
                        return false;
                    case { IsAbstract: true }:
                        context.Report(DiagnosticDescriptors.API0003, i, i!);
                        return false;
                    default:
                        context.Report(DiagnosticDescriptors.API0001, i, i!, i.TypeKind);
                        return false;
                }
            });

        SyntaxToken route = Identifier("route");
        IdentifierNameSyntax routeName = IdentifierName(route);
        SyntaxToken serviceToken = Identifier("service");
        IdentifierNameSyntax service = IdentifierName(serviceToken);
        SyntaxToken addScopedToken = Identifier("AddScoped");

        MethodDeclarationSyntax registry = MethodDeclaration(
            TypeSyntaxes.IServiceCollection,
            Identifier("AddEndpoints"))
            .WithParameterList(
            ParameterList(
                Parameter(serviceToken)
                    .WithType(TypeSyntaxes.IServiceCollection)
                    .WithModifiers(
                        TokenList(
                            SyntaxKind.ThisKeyword.Token))
                    .AsSingleton()))
            .WithBody(
                Block(
                    types
                        .Where(i => !i.IsStatic)
                        .Select(type => service
                            .InvokeMethod(addScopedToken.AsGeneric(ParseTypeName(type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat))))
                            .AsStatement())
                        .Concat([ReturnStatement(service)])
                        .AsSeparatedList()))
            .WithModifiers(
                TokenList(
                    SyntaxKind.PublicKeyword.Token,
                    SyntaxKind.StaticKeyword.Token));

        IEnumerable<MethodDeclarationSyntax> endpoints = types
            .SelectMany(type => type
                .GetMembers()
                .OfType<IMethodSymbol>()
                .Select(EndpointMethodInfo.Generate(i => i.Kebaberize())))
            .SelectMany(i => i.GenerateCode(routeName).Select(j => (i.Group, Code: j)))
            .GroupBy(i => i.Group, i => i.Code)
            .Select(group =>
                MethodDeclaration(
                    PredefinedType(
                        SyntaxKind.VoidKeyword.Token),
                    Identifier($"Map{group.Key}Endpoints"))
                .WithParameterList(
                    ParameterList(
                        Parameter(route)
                            .WithType(TypeSyntaxes.IEndpointRouteBuilder)
                            .WithModifiers(
                                TokenList(
                                    SyntaxKind.ThisKeyword.Token))
                            .AsSingleton()))
                .WithBody(Block(group.AsSeparatedList()))
                .WithModifiers(
                    TokenList(
                        SyntaxKind.PublicKeyword.Token,
                        SyntaxKind.StaticKeyword.Token))
            );

        CompilationUnitSyntax code = CompilationUnit()
            .WithLeadingTrivia(
                TriviaList(
                    Comment($"// Generated by {typeof(EndpointsGenerator).FullName}"),
                    Comment($"//      ❤️ from frg2089"),
                    Trivia(
                        NullableDirectiveTrivia(SyntaxKind.EnableKeyword.Token, true))
                    ))
            .WithUsings(
                List([
                    UsingDirective(IdentifierName("System")),
                    UsingDirective(IdentifierName("Microsoft.AspNetCore.Builder")),
                    UsingDirective(IdentifierName("Microsoft.AspNetCore.Hosting")),
                    UsingDirective(IdentifierName("Microsoft.AspNetCore.Http")),
                    UsingDirective(IdentifierName("Microsoft.AspNetCore.Routing")),
                    UsingDirective(IdentifierName("Microsoft.Extensions.DependencyInjection")),
                    ]))
            .WithMembers(
                SingletonList<MemberDeclarationSyntax>(
                    FileScopedNamespaceDeclaration(IdentifierName(KnownTypes.CommonNamespace[8..]))
                    .WithMembers(
                        List<MemberDeclarationSyntax>([
                            ClassDeclaration("GeneratedEndpoints")
                                .WithMembers(
                                    List<MemberDeclarationSyntax>([registry,..endpoints]))
                                .WithModifiers(
                                    TokenList(
                                        SyntaxKind.InternalKeyword.Token,
                                        SyntaxKind.StaticKeyword.Token,
                                        SyntaxKind.PartialKeyword.Token))
                                    ]))));

        context.AddSource("GeneratedEndpoints.g.cs", code.NormalizeWhitespace().ToFullString());
    }
}

